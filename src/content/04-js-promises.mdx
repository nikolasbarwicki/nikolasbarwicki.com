---
title: "Promise - podstawy"
slug: promise-w-javascript-podstawy
date: 2021-04-18
category: javascript
published: true
---

### Wstp

_Promise_ w Javascript to obiekt, kt贸ry w przyszoci mo偶e zwr贸ci warto - rozwizanie obietnicy `resolved` lub pow贸d dla kt贸rego obietnica zostaa odrzucona (np. bd sieci). _Promise_ w daneym momencie znajduje si w jednym z trzech stan贸w: `fulfilled` (_rozwizana_), `rejected` (_odrzucona_) lub `pending` (_oczekujca_).

Funkcj znadujc si wewntrz _promise_ nazywamy egzekutorem. W momencie stworzenia obietnicy egzekutor jest wywoywany od razu. Wewntrz niego zawarty jest kod, dziki kt贸remu otrzymujemy oczekiwany przez nas rezultat.

Argumentami egzekutora s `resolve` i `reject` s to _callbacki_ pochodzce bezporednio z Javascriptu. Egzekutor po wykonaniu swojego zadania i otrzymaniu rezultatu powinien wywoa jeden z tych dw贸ch callback贸w w zale偶noci od uzyskanego rezultatu:

- `resolve(value)` - jeli zadanie egzekutora zostao wykonane pomlnie, gdzie `value` jest rezultatem pochodzcym z jego realizacji
- `reject(error)` - jeli w trakcie dziaania egzekutora wystpi bad, gdzie `error` jest wartoci otrzymanego bedu.

### Waciowoci obiektu _promise_

Obiekt _promise_ zwr贸cony z konstruktora `new Promise` posiada nastpujce waciwoci:

- `state` - pocztkowo majcy warto `pending`, nastpnie na skutek wykonania kodu znajdujcego si w egzekutorze zmienia si na `fullfiled` kiedy w przypadku wywoania _callbacku_ `resolve`, lub `rejected` dla _callbacku_ `reject`
- `result` - pierwotnie o wartoci `undefined`, potem zmieniany sie na `value` bdce argumentem wywoanego `resolve(value)`, lub na warto `error` kiedy `reject(error)` jest wywoany.

W Javascript nie mamy bezporedniego dostpu do waciowci `state` i `result`. Obiekt _promise_ jest pewnego rodzaju cznikiem midzy egzekutorem, a funkcjami kt贸re wykorzysuj rezultat jego dziaania. Jest to powodem, dla kt贸rego u偶ywamy metod `.then`, `.catch` i `.finally` w celu skorzystania z wartoci waciwoci `state` i `result` o czym w dalszej czci wpisu.

### Rozwizanie i odrzucenie obietnicy.

Poni偶ej widzimy przydkad prostej obietnicy. Egzekutor jest wywoywany od razy przy tworzoniu obietnicy dziki skadni `new Promise`.

```jsx
const willGetAPayRise = new Promise(function (resolve, reject) {
  // funkcja powy偶ej jest wywoywana natychmiastowo po utworzeniu obiektu obietnicy

  // po 1 sekundzie dowiadujemy si, 偶e zadanie zostao wykonane pomylnie,
  // a jego rezultatem jest "otrzymujesz podwy偶k"
  setTimeout(() => resolve("+500 z "), 1000)
})
```

Otrzymuje on dwa argumenty `resolve` i `reject`. Jeden z nich powinien zosta wywoany po wykonaniu zadania przypisanego do naszej obietnicy. W przypadku poni偶ej przy u偶yciu `setTimeout` pozorujemy sytuacje, w kt贸rej rezultat obietnicy nie jest natychmiastowy - jest to operacja wymagajca czasu. Po sekundzie "wykonywania zadania" egzekutor wywouje `resolve("done")` , gdzie `"done"` jest wartoci, kt贸r zwraca obietnica. Wywoanie `resolve()` powoduje, te偶 zmian stanu obietnicy na `fullfiled`.

W przypadku niepowodzenia wykonania zadania przypisanego do naszej obietnicy r贸wnie偶 zwr贸ci ona warto - w tym przypadku jest jest obiekt `Error` z wiadomoci _"spr贸buj innym razem "_.

```jsx
const willGetAPayRise = new Promise(function (resolve, reject) {
  // po 1 sekundzie dowiadujemy si, 偶e zadanie zostao wykonane,
  // a jego rezultatem jest bd z wiadomoci "spr贸buj innym razem "
  setTimeout(() => reject(new Error("spr贸buj innym razem ")), 1000)
})
```

R贸wnie偶 jak w przykadzie poprzednim zastosowano `setTimeout`, kt贸ry op贸藕nia uzyskanie rezultatu obietnicy o 1 sekunde. Finalnie stan obietnicy zmienia si na `rejected`.

### `.then`

W celu wykonywania operacji na wartociach zwracanych z obietnic mo偶emy u偶ywa metod `.then`, `.catch` oraz `.finally`. Metoda `.then` mo偶e przyj dwa argumenty. Argumentami podwanymi do tej metody s funkcj.

```jsx
promise.then(
  function(result) // do obsugi rozwizanej obietnicy
  function(error) // do obsugi odrzuconej obietnicy
);
```

W przypadku pierwszego argumentu mamy funkcje, kt贸ra zostanie wywoana przy rozwizaniu obietnicy, za funkcja bdca drugim argumentem wywoana bdzie gdy obietnica zostanie odrzucona.

Poni偶ej widzimy przkady u偶yte poprzednio lecz teraz zostay one poszerzone o praktyczne zastosowanie metody `.then` kt贸ra pozwala nam na wykonaniu po偶danych przez nas operacji na rezultacie wykonania obietnicy.

```jsx
const willGetAPayRise = new Promise(function (resolve, reject) {
  setTimeout(() => resolve("+500 z "), 1000)
})

// resolve() wywouje pierwsz funkcj
willGetAPayRise.then(
  result => alert(result), // zwraca "+500 z " po 1 sekundzie
  error => alert(error) // nie jest wywoane
)

const willGetAPayRise = new Promise(function (resolve, reject) {
  setTimeout(() => reject(new Error("spr贸buj innym razem ")), 1000)
})

// reject() wywouje drug funkcj
willGetAPayRise.then(
  result => alert(result), // nie jest wywoane
  error => alert(error) // zwraca "Error: spr贸buj innym razem " po 1 sekundzie
)
```

### `.catch`

Metoda `.catch` przeznaczona jest to obsugi bd贸w - wykonania operacji na wartociach zwracanych z obietnic odrzuconych - ze stanem `rejected`

```jsx
const willGetAPayRise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("spr贸buj innym razem ")), 1000)
})

willGetAPayRise.catch(alert) // shows "Error: Whoops!" after 1 second
```

Po co nam metoda `.catch` skoro ten obsug bd贸w mielimy ju偶 przy metodzie `.then`? Metoda ta jest analogiczna do zapisu `.then(null, fn)` - jest to po prostu sk贸rcenie zapisu zwikszajace czytelno naszego kodu

### `.finally`

Metoda `.finally(fn)` jest analogiem do zapisu `.then(fn, fn)`. Zostaje ona wywoana _niezale偶nie_ od tego czy obietnica zostaje rozwizana czy odrzucona. Do wywoania metody `.finally` wymagany jest stan obietnicy `settled` i wystpuje on zar贸wno w kiedy obietnica ma status `resolved` jak i `rejected`. Metoda ta mo偶e by u偶ywana na przykad do ukrycia z interfejsu element贸w sugerujcych u偶ytkownikowi wykonywanie operacji asynchronicznej - ukrycie spinnera pojawiajcego si w trakcie oczekiwania na odpowied藕 z serwera.

```jsx
new Promise((resolve, reject) => {
  /* wykonuje operacj wymagajc czasu */
})
  // wywoane jest zar贸wno przy rozwizaniu jak i odrzuceniu obietnicy
  .finally(() => usu spinner z interfejsu u偶ytkownika)
  // spinner jest usuwany zawsze przed obsu偶eniem rezultatu obietnicy
  .then(result => show result, err => show error)
```

W przykadzie powy偶ej mo偶emy zauwa偶y, 偶e `.finally` nie przyjmuje 偶adnych argument贸w - z jego wywoania nie mo偶emy dowiedzie czy czy obietnica zostaa rozwizana czy odrzucona. Widzimy tak偶e 偶e `.finally` nie blokuje wykonania dlaszych metod. Mo偶emy zastosowa wiele wywoa tej metody przed `.then` lub `.catch` i nie bdzie to miao wpywu na ich wywoanie.

### Tylko jeden rezultat

Egzekutor powninen wywoa jednokrotnie `resolve` lub `reject`. Zmiana stanu obietnicy jest ostateczna i kolejne wywoanie `resolve` lub `reject` nie ma wpywu na jej stan i jest zwyczajnie ignorowane. Pierwsze wywoanie jednej z tych metod jest znaczce.

```jsx
const willGetAPayRise = new Promise(function (resolve, reject) {
  resolve("+500 z ")

  reject(new Error("spr贸buj innym razem ")) // pominite
  setTimeout(() => resolve("+500 z ", "+1500 z 梆梆")) // pominite
})
```

Warto tu doda, 偶e poza ignorowaniem kolejnych pr贸b zmiany stanu obietnicy ignorowane s tak偶e dodatkowe arugmenty przekazywane do funkcji `resolve/reject`. Zwr贸cony z obietnicy mo偶e zosta tylko pierwszy argument (lub jego brak), ka偶dy kolejny argument bdzie pominity.

### Zastosowanie praktyczne

Poni偶ej przedstawiony zosta przykad zastosowania obietnic taki, kt贸ry powinnien by nam du偶o lepiej znany. To wanie dziki nim mo偶emy komunikowa frontend z backendem w spos贸b nie wpywajcy niekorzystnie na u偶ytkowanie naszych aplikacji. Na potrzeby przykadu skonstuujemy funkcje udajc zastosowanie funkcji `fetch` lub wykorzystanie bilbioteki `axios` obie one zwaracaj przecie偶 obietnice.

Stw贸rzmy najpierw funkcj, kt贸ra jako argument przyjmie warto wskazujc na _url_ koc贸wki API z potrzebnym nam zasobem za zwraca ona bdzi wanie _promise_. Zastosowanie funkcji `setTimeout` ponownie ma udawa fakt obcowania z prawdziwym API korzystajcym z bazy danych.

```jsx
const fakeRequest = (url) => {
	return new Promise((resolve, reject) => {
		setTimeout(() => {
				// tu bdzie dalszy kod
			}
		}, 3000)
	})
}
```

W prawdziwym przypadku, na skutek r贸偶nicych przyczyn, nie zawsze otrzymujemy pozyzytywn odpowied藕 z serwera. Napotykamy czsto bedy wynikajce z jego nadmiernego obci偶enia, bdnej autoryzacji lub braku 偶danego zasobu. W naszym kodzie zasymulujemy takie sytuacje przez generowanie losowej liczby przy u偶yciu `Math.random()` zwarajcej losow liczb z przdziau od 0 do 1.

```jsx
const fakeRequest = url => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const rand = Math.random()

      if (rand < 0.3) {
        reject()
      } else {
        resolve()
      }
    }, 3000)
  })
}
```

W przypadku warto `rand` mniejszej od 0.3 nasza obietnica zostanie odrzucona, w pozostaych sytuacjach wywoana zostanie funkcja `resolve()`. Dodajmy zatem nasze _zasoby_, kt贸re mo偶emy 偶da od naszego _API_.

```jsx
const fakeRequest = url => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const rand = Math.random()

      if (rand < 0.3) {
        reject()
      } else {
        const pages = {
          "/zoo": [
            { id: 1, animal: "" },
            { id: 2, animal: "" },
          ],
          "/about": "Lorem ipsum",
        }
        const data = pages[url]
        resolve()
      }
    }, 3000)
  })
}
```

Dodany zosta obiekt `pages` zawierajcy interesujce nas dane. Mo偶emy zapisa je do zmiennej `data` poprzez u偶ycie odpowiedniego klucza bdcego naszym argumentem funkcji `fakeRequest`.

Finalnie przygotujmy wartoci zwracane przez nasz obietnice. W przypadku jej odrzucenia otrzymamy obiekt zawierajcy `status: 500` informujcy o niepowodzeniu w rozwizaniu naszej obietnicy. Za dla funkcji `resolve()` zwr贸cony nam zostanie obiekt ze statusem informujcym nas o powodzeniu operacji oraz obietkem z oczekiwanymi przez nas danymi.

```jsx
const fakeRequest = url => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      const rand = Math.random()

      if (rand < 0.3) {
        reject({ status: 500 })
      } else {
        const pages = {
          "/zoo": [
            { id: 1, animal: "" },
            { id: 2, animal: "" },
          ],
          "/about": "Lorem ipsum",
        }
        const data = pages[url]
        resolve({ status: 200, data })
      }
    }, 3000)
  })
}
```

Brakujcym elementem caoci jest obsu偶enie rezultatu rozwizania naszej obietnicy. Zastosujemy w tym celu metody `.then` i `.catch`. W tym przypadku pod argumentem `res` kryje si warto wynikajca z rozwizania naszej obietnicy. W przypadku pomylnego rozwizania obietnicy w konsoli zobaczymy obiekt: `{status: 200, data: [{id: 1, animal: '``'},{id: 2, animal: '``'}]`za dla odrzucenia obietnicy w konsoli pojawi si warto `500` bdca wartoci klucza `status` zwracanej wartoci.

```jsx
fakeRequest("/zoo")
  .then(res => {
    console.log(res)
    console.log("Sukces")
  })
  .catch(res => {
    console.log(res.status)
    console.log("Pora偶ka")
  })
```

### Podsumowanie

Mam nadzieje, 偶e po tym wyczerpujcym om贸wieniu obietnice w Javascript nie stanowi, 偶adnego problemu i wszystkie zagadki za nimi stojce nie s ju偶 偶adn tajemnic. Zrozumienie zagadanienia asynchronicznoci w Javascript sprawa trudnoci wielu osobom ale jest niezbdne do swobonej pracy z tym jzykiem, zar贸wno na frontendzie jak i backendzie. W kolejnych wpisach z pewnoci porusz zagadnienie _promise chaining_, zgbie temat obsugi bd贸w oraz przyjrz si skadni `async/await`.
