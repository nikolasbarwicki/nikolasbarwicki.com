---
title: "Destrukturyzacja w Javascript"
slug: destrukturyzacja-w-javascript
date: 2021-04-04
category: javascript
published: true
popular: true
---

## Rozpakowywanie tablic i obiektÃ³w

Obiekty i tablice sÄ… strukturami danych umoÅ¼liwiajÄ…cymi nam na przechowywanie danych w uporzÄ…dkowany sposÃ³b. CzÄ™sto zdarzajÄ… siÄ™ sytuacjÄ™, w ktÃ³rych nie potrzebujemy wykorzystywaÄ‡ caÅ‚ego obiektu/tablicy lecz tylko ich **pojedynczych elementÃ³w**. Z pomocÄ… wtedy przychodzi nam _destrukturyzacja_ w Javascripcie.

## Destrukturyzacja tablic

Przed ES6 aby przypisaÄ‡ wartoÅ›ci z tablicy do zmiennych musieliÅ›my definiowaÄ‡ kaÅ¼dÄ… zmiennÄ… **oddzielnie**:

```javascript
const zoo = [ğŸ™, ğŸ¦«, ğŸ¦­]

const oÅ›miornica = arr[0]

const bÃ³br = arr[1]
```

Przy zastosowaniu nowej skÅ‚adni moÅ¼emy uzyskaÄ‡ ten sam rezultat w znacznie krÃ³tszy i bardziej czytelny sposÃ³b:

```javascript
const [oÅ›miornica, bÃ³br] = [ğŸ™, ğŸ¦«, ğŸ¦­]
// oÅ›miornica = ğŸ™
// bÃ³br = ğŸ¦«
```

NaleÅ¼y pamiÄ™taÄ‡, Å¼e do destrukturyzacji dochodzi poprzez kopiowanie elementÃ³w do nowych zmiennych - **tablica ÅºrÃ³dÅ‚owa pozostaje niezmieniona**.

## Pomijanie, ...rest oraz wartoÅ›ci domyÅ›lne

W poprzednim przykÅ‚adzie widzimy, Å¼e do zmiennych zostaÅ‚y zapisane kolejne elementy tablicy. Zapytacie teraz, co gdybyÅ›my chcieli **pominÄ…Ä‡ jeden lub wiÄ™cej elementÃ³w** - czy jest to moÅ¼liwe? OczywiÅ›cie! IgnorowaÄ‡ wartoÅ›ci przy destrukturyzacji tablic moÅ¼emy w nastÄ™pujÄ…cy sposÃ³b:

```javascript
const [oÅ›miornica, , foka] = [ğŸ™, ğŸ¦«, ğŸ¦­]
// oÅ›miornica = ğŸ™
// foka = ğŸ¦­
```

Bardziej skomplikowanym przypadkiem ignorowania elementÃ³w tablicy jest zastosowanie operatora `...rest` . Pozwala on na przyporzÄ…dkowanie elementÃ³w tablicy, ktÃ³rych nie potrzebujemy zapisywaÄ‡ w oddzielnych zmiennych w nowej tablicy:

```javascript
const [oÅ›miornica, ...rest] = [ğŸ™, ğŸ¦«, ğŸ¦­]
// oÅ›miornica = ğŸ™
// rest = [ğŸ¦«,ğŸ¦­]
```

KolejnÄ… ciekawÄ… moÅ¼liwoÅ›ciÄ… jakÄ… oferuje nam destrukturyzacja jest moÅ¼liwoÅ›Ä‡ nadania wartoÅ›ci domyÅ›lnych. W przypadku gdy element tablicy jest typu `undefined` moÅ¼emy nadaÄ‡ mu wczeÅ›niej przypisanÄ… wartoÅ›Ä‡:

```javascript
const zoo = [undefined, ğŸ¦«, ğŸ¦­]
const [oÅ›miornica = ğŸ™, ğŸ¦«, ğŸ¦­] = zoo
// oÅ›miornica = ğŸ™
// bÃ³br = ğŸ¦«
// foka = ğŸ¦­
```

## Destrukturyzacja obiektÃ³w

W podobny sposÃ³b moÅ¼emy dziaÅ‚aÄ‡ rÃ³wnieÅ¼ na obiektach. Przyjrzyjmy siÄ™ przykÅ‚adowi podobnemu jak przedstawiony na samym poczÄ…tku, lecz w tym przypadku dla obiektÃ³w. Ponownie Å‚atwo zauwaÅ¼yÄ‡, Å¼e dziÄ™ki zastosowaniu destrukturyzacji otrzymujemy duÅ¼o czytelniejszy i milszy dla oka kod.

```javascript
// Stary syntax
const obiad = {
  zupa: ğŸœ,
  stek: ğŸ¥©,
  kompot: ğŸ¥¤,
}

const zupa = obiad.zupa
const stek = obiad.stek
const kompot = obiad.kompot

// Nowy syntax
const { zupa, stek, kompot } = obiad

// zupa = ğŸœ
// stek = ğŸ¥©
// kompot = ğŸ¥¤
```

## Ponownie wartoÅ›ci domyÅ›lne oraz zmiany nazw zmiennych

RÃ³wnieÅ¼ dla obiektÃ³w otrzymujemy moÅ¼liwoÅ›Ä‡ nadania **wartoÅ›ci domyÅ›lnych** zgodnie z przykÅ‚adem poniÅ¼ej:

```javascript
const obiad = {
  zupa: undefined,
  stek: ğŸ¥©,
  kompot: ğŸ¥¤,
}

const { zupa = ğŸœ, stek, kompot } = obiad
```

Co w przypadku, w ktÃ³rym klucz w obiekcie ma **takÄ… samÄ… wartoÅ›Ä‡** jak nazwa juÅ¼ zdefiniowanej uprzednio zmiennej? Nie moÅ¼emy posiadaÄ‡ w tym samym zakresie dwÃ³ch niezaleÅ¼nych zmiennych o tej samej nazwie. Tutaj z pomocÄ… przychodzi nam moÅ¼liwoÅ›Ä‡ przypisania wartoÅ›ci do zmiennej o dowolnej nazwie:

```javascript
const obiad = {
  zupa: ğŸœ,
  stek: ğŸ¥©,
}

const { zupa: kapuÅ›niaczek } = obiad
// kapuÅ›niaczek = ğŸœ
```

## ZagnieÅ¼dzenia i argumenty funkcji

PowyÅ¼sze przykÅ‚ady pokazywaÅ‚y jak pracowaÄ‡ na prostych obiektach. W przypadku zagnieÅ¼dÅ¼onych obiektÃ³w destrukturyzacja rÃ³wnieÅ¼ jest moÅ¼liwa:

```javascript
const kurnik = {
  kura: {
    kurczak: ğŸ£,
  },
}

const {
  kura: { kurczak },
} = kurnik

// kurczak = ğŸ£
```

Dla obiektÃ³w, podobnie jak dla tablic, mamy moÅ¼liwoÅ›Ä‡ skorzystania z operatora `...rest`.

```javascript
let samolot = {
  model: "A321",
  pilot: ğŸ‘©ğŸ»â€âœˆï¸,
  fotel: ğŸ’º,
}

let { model, ...rest } = samolot
// model = "A321"
// rest.pilot = ğŸ‘©ğŸ»â€âœˆï¸
// rest.fotel = ğŸ’º
```

Ostatnim zastosowaniem destrukturyzacji jest uÅ¼ywanie jej wewnÄ…trz funkcji. DziÄ™ki temu moÅ¼emy operowaÄ‡ na wÅ‚aÅ›ciowoÅ›ciach obiektu przekazanego jako argument funkcji. ZnajÄ…c wÅ‚aÅ›ciwoÅ›ci obiektu bÄ™dÄ…cego arugmentem funkcji moÅ¼emy dokonaÄ‡ destrukturyzacji zgodnie z przykÅ‚adem:

```javascript
const user = { id: 0, username: "Andrzej" }

function siemaAndrzej({ id, username }) {
  console.log(`czeÅ›Ä‡ ${username}`)
}

siemaAndrzej(user)
// 'czeÅ›Ä‡ Andrzej'
```

Osoby zaznajomione z Reactem mogÄ… dostrzegaÄ‡ pewien powtarzajÄ…cy siÄ™ schemat. Zgodnie z dobrymi praktykami powinniÅ›my dokonywaÄ‡ destrukturyzacji obiektu `props` w komponentach Reaktowych. Przy takiej operacji robimy dokladnie to samo co w poprzednim przykÅ‚adzie - "rozpakowujemy" obiekt `props` i wyjmujemy z niego potrzebne nam wartoÅ›ci zmiennych. PoniÅ¼ej przykÅ‚ad dla funkcyjnego komponentu reaktowego zwracajÄ…cego nam przycisk:

```jsx
const Button = ({ text, type }) => {
  return <button type={type}>{text}</button>
}

// inny zapis
const Button = props => {
  const { text, type } = props

  return <button type={type}>{text}</button>
}
```

## Podsumowanie

CiÄ™Å¼ko nie zgodziÄ‡ siÄ™ z obserwacjÄ…, Å¼e kod z umiejÄ™tnym zastosowaniem destrukturyzacji jest z pewnoÅ›ciÄ… bardziej czytelny i uporzÄ…dkowany. MoÅ¼liwoÅ›ci Javascriptu w tej kwestii, przed ES6, byÅ‚y nieco ograniczone i prowadziÅ‚o to do powstawania nadamiaru niepotrzebnego kodu. ZnajÄ…c wszystkie moÅ¼liwoÅ›ci opisane w tym artykule z pewnoÅ›ciÄ… moÅ¼emy sprawiÄ‡ aby nasz kod byÅ‚ bardziej przyjazny zarÃ³wno dla nas, jak i dla innych deweloperÃ³w, z ktÃ³rymi mamy okazjÄ™ pracowaÄ‡.
