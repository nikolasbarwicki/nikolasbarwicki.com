---
title: "Wprowadzenie do Next.js"
slug: wprowadzenie-do-next
date: 2021-05-02
category: next
published: true
popular: true
---

## Wstp

Budowanie aplikacji zawsze wi偶e si z rozwizywaniem bardziej lub mniej zo偶onych problem贸w. Na szczcie nowe technologie przychodz nam z pomoc i rozwizuj wiele z nich ju偶 na samym pocztku. Dziki temu, my deweloperzy, mo偶emy si skupi na zagadnieniach istotnych z punktu widzenia biznesu i zacz dostarcza funkcjonalny kod **jeszcze szybciej**.

Wyb贸r technologii do danego projektu jest uzale偶niony od wielu czynnik贸w ale ci偶ko si nie zgodzi, 偶e obecnie w rodowisku frontendu **kr贸luje React**. Ka偶dy kto mia z nim kontakt z pewnoci wie czym jest _Create React App (CRA)_, jednak w ostatnim czasie na popularnoci zyskao nowe rozwizanie r贸wnie偶 oparte o Reacta - Next.js.

## Create React App (CRA)

Jest to narzdzie oszczedzajce nam czasu na konfiguracji naszego rodowiska deweloperskiego. Za pomoc jednej komendy otrzymujemy gotowy projekt oparty o Reakta bez powicania czasu na zrozumienie i konfiguracje Babel i Webpacka. Jednak ka偶dy kij ma dwa koce. Dziki pozornej oszczdnoci na starcie nie zawsze otrzymujemy **idealn aplikacje produkcyjn**. Gdy pochylimy si nad zagadnieniami **SEO** lub **optymalizacji wydajnoci** oka偶e si, 偶e potrzebujemy mocno zaintegerowa w startow konfiguracj, kt贸ra oferuje nam CRA. Midzy innymi wzgldu na ograniczenia, kt贸re nakada na nas CRA powsta Next.js, kt贸ry ma zaoferowa powiew wie偶oci w rodowisku frontendu.

## Next.js

Jest to framework open-source oparty na Node.js i Babel stworzony przez Vercel. Korzysta on ze wszystkich zalet Reacta, a jego najwiksz przewag nad CRA jest wspieranie **server-side renderingu**. Wspiera on:

- server-side rendering **(SSR)**
- static exporting **(SSG)**

w odr贸偶nieniu od CRA, kt贸re opiera si na renderowaniu aplikacji po stronie klienta **(CSR)**. Powy偶sze r贸偶nice pozwalaj na wygenerowanie stron po stronie serwera, co niewtpliwie jest wielk zalet w **kontekcie SEO i wydajnoci**.

Ponadto g贸wnymi zaletami zastosowania Next.js s:

- znacznie **uproszczony routing** wzgldem CRA - nie musimy instalowa `react-router`, korzystamy z routera dostarczonego przez Next.js i strukur nawigacji w naszej aplikacji okrela struktura folder贸w w naszym projekcie (o czym wicej p贸藕niej)
- cie偶ki API - mo偶emy stworzy **wasne REST API** dziki Next.js i zasila nasz aplikacj w dane pochodzce np. z zewntrznej **bazy PostgreSQL**,
- mnogo konfiguracji startowych projektu - podczas tworzenia naszego projektu przy pomocy `create-next-app` mo偶emy wybra **startow konfiguracj** zawierajc np. Typscript, styled-components lub saas. Oszczedzamy przy tym wiele czasu i nie musimy przy ka偶dym projekcie powtarza tych samych czynnoci,
- server-side generation - przy u偶yciu `next export` mo偶emy wyeksportowa nasz aplikacje do **statycznego HTML**, kt贸ry mo偶e by u偶ywany bez serwera z Node.js - na dowolnym hostingu stron statycznych lub CDN'ie.
- atwy deployment - platforma Vercel pochodzi od tw贸rc贸w Nexta, przy pomocy kilku klikni nasza aplikacja jest dostpna dla u偶ytkownik贸w z caego wiata

## Nasza pierwsza aplikacja Next.js

Wymagania startowe: 偶eby wykorzysta ten artyku w peni rekomenduj znajomo Javascriptu () i podstaw Reakta (tworzenie komponent贸w, zastosowanie JSX, przekazywanie props贸w, u偶ywanie stanu w komponentach).

## Pocztkowa konfiguracja

Do utworzenia naszego pierwszego projektu potrzebowa bdziemy zainstalowanego Node.js w wersji 10.13 lub nowszej.

呕eby wystartowa nasz projekt u偶ywamy komendy:

```jsx
npx create-next-app
// lub
yarn create next-app
```

Do tego przy u偶yciu flagi `-e` mo偶emy wybra przykadowy projekt z gotow konfiguracj rozwiza potrzebnych do naszych zastosowa. Jest ich naprawd niezliczona ilo i mo偶na si z nimi zapozna pod [tym linkiem.](https://github.com/vercel/next.js/tree/canary/examples)

```jsx
npx create-next-app -e with-typescript-styled-components
// utworzy dla nas projekt Next.js ze wsparciem Typescript i styled-components
```

## Struktura projektu

Po wykonaniu si powy偶szej komendy otrzymujemy projekt zawierajcy kilka folder贸w:

- `public` zawiera pliki dostpne dla ka偶dego u偶ytkownika, wpisujc `adres-strony.com/favicon.ico` zobaczymy domyln favicon z naszego projektu,
- `styles` - domylnie zawiera wszystkie style dla naszej aplikacji, zastosowane zostay CSS Modules, plik `global.css` zawiera style globalne, zas `*.module.css` odnosz si do poszczeg贸lnych komponent贸w/stron.
- `pages` - najwa偶niejszy folder z punktu widzenia zao偶e Nexta. `index.js` jest w tym przypadku nasz stron domow dostpn pod cie偶k `/`. Jest to znany nam ju偶 komponent Reaktowy o nazwie Home. `_app.js` jest naszym komponentem, kt贸ry "oplata" pozostae strony wywietlane przez Nexta, tutaj te偶 importujemy np. globalne style `globals.css`. W tym folderze ustalamy **ca struktur nawigacyjn projektu**.

## Komponent Head

W celu dodania naszych wasnych **tytu贸w stron, metatag贸w lub opis贸w** u偶ywamy komponentu `Head` pochodzcego z paczki `next/head`. U偶ywamy go jak klasycznego tagu `head` w strukturze pliku _html_.

```jsx
<Head>
  <title>My page title</title>
  <meta name="viewport" content="initial-scale=1.0, width=device-width" />
  <meta property="og:title" content="My page title" key="title" />
  <meta name="keyword" content="kangur, panda" />
</Head>
```

## Komponent Layout

Wykorzystujc fakt, i偶 `_app.js` niejako "oplata" nasze pozostae strony i jest wywietlany zawsze, niezale偶nie od cie偶ki - i tym samym wywietlanej strony mo偶emy przygotowa komponent `Layout` zawierajcy powatrzajce si elementy dla ka偶dej ze stron - najczciej umieszczona tam mo偶e by nawigacja, bd藕 zawierajcy j `header` i/lub `footer`

<Callout>
  Jak pewnie zd偶ye zauwa偶y do nazywania plik贸w stosujemy konwencje nazywania
  komponent贸w z wielkiej litery - Layout.js, za dla plik贸w zawierjacych strony
  u偶ywamy tylko maych liter - index.js
</Callout>

Stw贸rzmy `Layout` zawierajcy style dla naszego g贸wnego kontenera oraz wysietlajcy komponent nawigacji oraz `headera` dla ka偶dej ze cie偶ek:

```jsx
// Layout.js
import styles from "../../styles/Layout.module.css"
import Nav from "./Nav"
import Header from "./Header"

const Layout = ({ children }) => {
  return (
    <>
      <Nav />
      <div className={styles.container}>
        <main className={styles.main}>
          <Header />
          {children}
        </main>
      </div>
    </>
  )
}

export default Layout
```

```jsx
// _app.js
import Layout from "../components/Layout"
import "../styles/globals.css"

function MyApp({ Component, pageProps }) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  )
}

export default MyApp
```

## Nawigacja i linki w Next.js

Przygotujmy prosty komponent nawigacji i zepnijmy go z routerem z Nexta. W pierwszej kolejnoci importujemy `Link` z `next/link`. Mechanizm dziaania jest zbli偶ony do tego, kt贸ry znamy z _react-router_. Jako parametr `href` podajemy cie偶k. W naszym przypadku jest to strona g贸wna oraz podstrona _About_ znadujca si pod cie偶k _/about._

```jsx
import Link from "next/link"
import navStyles from "../styles/Nav.module.css"

const Nav = () => {
  return (
    <nav className={navStyles.nav}>
      <ul>
        <li>
          <Link href="/">Home</Link>
        </li>
        <li>
          <Link href="/about">About</Link>
        </li>
      </ul>
    </nav>
  )
}
```

Aby wszystko dziaao zgodnie z naszym zamysem struktura katalogu _pages_ powinna zawiera w sobie plik `index.js` z zawartoci, kt贸r chcemy zobaczy bedc na cie偶ce `/` oraz plik `about.js` zawierajcy tre odpowiadajc cie偶ce `/about`.

## Warstwa danych w naszej aplikacji

Next.js opiera si na **dw贸ch metodach pre-renderingu**: _static generation_ i _server-side rendering_. Postaram si wytumaczy r贸偶nice pomidzy nimi oraz metody zasilania naszej aplikacji danymi dla ka偶dej z nich.

Next oferuje nam trzy funkcje, kt贸re mo偶emy wykorzysta do pobierania danych przy pre-renderingu:

- `getStaticProps` - (_static generation_) - pobiera dane podczas budowania projektu
- `getServerSideProps` - (_server-side rendering)_ - pobiera dane przy ka偶dym zapytaniu
- `getStaticPaths` - (_static generation_) - dynamicznie generuje cie偶ki na podstawie pobranych danych

## `getStaticProps`

Funkcja ta pozwala nam na wykonanie pre-renderu strony na kt贸rej zostaa u偶yta podczas budowania projektu przy u偶yciu _props贸w_ zwr贸conych przez `getStaticProps`.

Wykonujemy w niej klasyczne zapytanie do koc贸wki API, w tym przypadku z u偶yciem `fetch`, pamitajc o dodaniu _async_ poniewa偶 jest to **kod asynchroniczny**. Nastpnie zwracamy z funkcji, znany r贸wnie偶 z CRA, klasyczny obiekt _props_, w ktorym mo偶emy umieci dowolne dane do wykorzystania wewntrz naszego komponentu - strony.

```jsx
// article.js
const Article = ({ articles }) => {
  return <div>{articles.map(article => (
		<h1>{article.title}</h1>
	)}</div>
};

export const getStaticProps = async () => {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts?_limit=10`,
  );
  const articles = await res.json();

  return {
    props: {
      articles,
    },
  };
};
```

## `getServerSideProps`

Kolejn metod jest `getServerSideProps`. Za chwilk wr贸cimy do jej szczeg贸owego omawiania. Wydaje mi si, 偶e teraz jest najlepsza okazja, 偶eby pokaza w praktyce kolejne aspekty routingu w Next.js. Nasza strona ma wywietla artykuy pobrane z API. Na stronie g贸wnej `/` wywietlamy list artyku贸w pod postaci link贸w, r贸偶nicych si od siebie parametrem ID unikalnym dla ka偶dego ze wpis贸w.

Chcielibymy aby dostp do ka偶dego z nich znajdowa si pod cie偶k `/article/:id`. Aby uzyska takie dziaanie naszej nawigacji ponownie wykorzystamy **struktur plik贸w** w naszym projekcie.

W katalogu `pages` su偶cym do definiowania naszych cie偶ek tworzymy folder `article`, za w nim tworzymy plik o nazwie `[id].js`. Dziki temu Next.js na podstawie danych pochodzcych z API wygeneruje dla nas odpowiednie strony z treciami odpowiadajcymi ka偶demu, unikalnemu ID artykuu zgodnie z kodem poni偶ej:

```jsx
const Article = ({ article }) => {
  return (
    <>
      <h1>{article.title}</h1>
      <p>{article.body}</p>
    </>
  )
}

export const getServerSideProps = async context => {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${context.params.id}`
  )

  const article = await res.json()

  return {
    props: {
      article,
    },
  }
}

export default Article
```

Funkcja `getServerSideProps` zachowuje si bardzo podobnie do `getStaticProps` z poprzedniego przykadu. Zauwa偶aln r贸偶nic tutaj jest u偶ycie argumentu _context_. Jest to obiekt zawierajcy wiele danych, kt贸re mo偶emy wykorzystywa w naszych komponentach - [wicej w dokumentacji](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering) . W tym przypadku interesuje nas klucz _params_ zawierajcy nasze ID artykuu. Dziki "wyjciu" go z naszej cie偶ki mo偶emy wykona zapytanie do API zwracajce nam potrzebne dane dla danego posta.

## `getStaticPaths`

Ostatni funkcj oferowan nam przez przez Nexta jest `getStaticPaths` - zalecana jest ona przy u偶yciu dynamicznych cie偶ek i wymaga ona zdefiniowania listy cie偶ek dla kt贸rych ma zosta wyrenderowany HTML w momencie budowania projektu.

Klucz `paths` wskazuje na cie偶ki, kt贸re maj zosta poddane pre-renderingowi. W naszym przypadku nasz routing wskazuje na schemat `pages/article/[id].js`, a `paths` powinien wyglda w nastpujcy spos贸b:

```jsx
return {
  paths: [
    { params: { id: '1' } },
    { params: { id: '2' } }
  ],
  fallback: ...
}
```

Z powy偶szego kodu wynika, 偶e Next wygereuje statyczne `article/1` i `article/2` podczas budowania projektu wykorzysujc komponent strony znajdujcy si w `pages/article/[id].js`.

Zgodnie z konstrukcj odpowiedzi naszego API aby przygotowa tablice paths musimy u偶y funkcji `.map` na danych z serwera.

```jsx
export const getStaticPaths = async () => {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts?_limit=20`
  )

  const articles = await res.json()

  const ids = articles.map(article => article.id)
  const paths = ids.map(id => ({ params: { id: id.toString() } }))

  return {
    paths,
    fallback: false,
  }
}
```

Drugim, nieom贸wionym jeszcze kluczem jest `fallback`. R贸wnie偶, podobnie jak `paths` jest on wymagany i przyjmuje warto _true_ bd藕 _false_.

- dla wartoci `false` - w przypadku braku strony odpowiadajcej cie偶ce zwr贸conej przez `getStaticPaths` zostaniemy przeniesieni na **stron 404**.
- dla wartoci `true` - zmienia si zachowanie `getStaticProps`. cie偶ka, kt贸ra nie zostaa wygenerowana podczas budowania **nie bdzie skutkowa stron 404.** Zamiast tego Next.js zaserwuje nam _fallback page_ - wicej szczeg贸贸w pod [tym linkiem](https://nextjs.org/docs/basic-features/data-fetching#fallback-true). W wersji _fallback_ strony _propsy_ bd puste, a przy u偶yciu routera mo偶emy sprawdzi czy strona _fallback_ zostaa wyrenderowana - `router.isFallback` bdzie wartoci `true`.

Dalej u偶ywamy `getStaticProps` tak samo jak w przykadzie niewykorzystujcym `getStaticPaths`:

```jsx
export const getStaticProps = async context => {
  const res = await fetch(
    `https://jsonplaceholder.typicode.com/posts/${context.params.id}`
  )

  const article = await res.json()

  return {
    props: {
      article,
    },
  }
}
```

## Kiedy u偶y ka偶dej z opisanych funkcji?

`getStaticProps`

- dane wymagane do renderu strony s **dostpne ju偶 podczas budowania projektu**, znacznie przed zapytaniem przez u偶ytkownika
- dane pochodz z **headless CMS**
- dane **nie s unikalne** dla ka偶dego z u偶ytkownik贸w
- strona musi by prerenderowana, ze wzgld贸w SEO oraz by bardzo szybka

`getServerSideProps`

- tylko wtedy gdy strona musi by pre-renderowana, a jej dane musz by pobrane w momencie zapytania. Metoda ta bdzie wolniejsza od `getStaticProps` poniewa偶 serwer musi przetworzy rezultat przy ka偶dym zapytaniu
- jeli dane nie musz by pre-renderowane po stronie klienta warto rozwa偶y pobieranie danych po stronie klienta (np. [SWR](https://swr.vercel.app/))

`getStaticPaths`

- statyczny pre-rendering stron u偶ywajcy **dynamicznych cie偶ek**

## Podsumowanie

Przedstawiem podstawowe zagadnienia dotyczce Next.js. Zakres ten z pewnoci pozwala na stawianie **pierwszych krok贸w** przy jego u偶yciu. Z pewnoci jest jeszcze wiele aspekt贸w, kt贸re wymagaj szerszego om贸wienia. W nastpnych wpisach chtnie porusze zagadnienia **cie偶ek API** (np. z u偶yciem Prismy) czy **deploymentu** projekt贸w.

Myle, 偶e warto by wiadomym r贸偶nic pomidzy Nextem, a powszechnym _create-react-app_ i wiedzie kiedy zastosowanie ka偶dego z nich jest suszniejszym wyborem. Podejrzewam te偶, 偶e w niedalekiej przyszoci Next.js mocno zyska na popularnoci i skutecznie bdzie rozwiazywa problemy, kt贸remu CRA nie jest w stanie sprosta w prosty i przyjemny dla dewelopera spos贸b.
